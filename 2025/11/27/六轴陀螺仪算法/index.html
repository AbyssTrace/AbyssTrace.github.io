<!DOCTYPE html><html lang="zh-CN" data-theme="dark"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>六轴陀螺仪算法驱动飞鼠 | Shadow的博客</title><meta name="author" content="Shadow"><meta name="copyright" content="Shadow"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#0d0d0d"><meta name="description" content="​	简介：这个文档下包含了航博远达六轴陀螺仪项目和安卓TV鼠标项目的相关算法和问题 相关知识寄存器是什么 ？​	寄存器是CPU用来暂存指令、数据和地址的电脑存储器。它位于CPU内部，存储速度想对硬盘、内存和缓存来说几乎是最快的。 ​	其速度快的原因有三：1.由CPU中的逻辑单元直接存取。2.位于CPU中，与逻辑单元的走线短。3.寄存器自身的结构优势 屏幕坐标系​	屏幕坐标系是用于描述屏幕上像素位置">
<meta property="og:type" content="article">
<meta property="og:title" content="六轴陀螺仪算法驱动飞鼠">
<meta property="og:url" content="http://example.com/2025/11/27/%E5%85%AD%E8%BD%B4%E9%99%80%E8%9E%BA%E4%BB%AA%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Shadow的博客">
<meta property="og:description" content="​	简介：这个文档下包含了航博远达六轴陀螺仪项目和安卓TV鼠标项目的相关算法和问题 相关知识寄存器是什么 ？​	寄存器是CPU用来暂存指令、数据和地址的电脑存储器。它位于CPU内部，存储速度想对硬盘、内存和缓存来说几乎是最快的。 ​	其速度快的原因有三：1.由CPU中的逻辑单元直接存取。2.位于CPU中，与逻辑单元的走线短。3.寄存器自身的结构优势 屏幕坐标系​	屏幕坐标系是用于描述屏幕上像素位置">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251215174735747.webp">
<meta property="article:published_time" content="2025-11-26T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-15T09:51:31.015Z">
<meta property="article:author" content="Shadow">
<meta property="article:tag" content="嵌入式开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251215174735747.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "六轴陀螺仪算法驱动飞鼠",
  "url": "http://example.com/2025/11/27/%E5%85%AD%E8%BD%B4%E9%99%80%E8%9E%BA%E4%BB%AA%E7%AE%97%E6%B3%95/",
  "image": "https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251215174735747.webp",
  "datePublished": "2025-11-26T16:00:00.000Z",
  "dateModified": "2025-12-15T09:51:31.015Z",
  "author": [
    {
      "@type": "Person",
      "name": "Shadow",
      "url": "http://example.com"
    }
  ]
}</script><link rel="shortcut icon" href="https://free.picui.cn/free/2025/12/01/692d338aceed4.png"><link rel="canonical" href="http://example.com/2025/11/27/%E5%85%AD%E8%BD%B4%E9%99%80%E8%9E%BA%E4%BB%AA%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '六轴陀螺仪算法驱动飞鼠',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/assets/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://photography.satelliteorbit.space/"><i class="fa-fw fas fa-images"></i><span> 摄影集</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://note.satelliteorbit.space/%E7%AC%94%E8%AE%B0/"><i class="fa-fw fas fa-book"></i><span> 学习笔记</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://free.picui.cn/free/2025/12/01/692d4c54014d4.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Shadow的博客</span></a><a class="nav-page-title" href="/"><span class="site-name">六轴陀螺仪算法驱动飞鼠</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comments"></i><span> 分享</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://photography.satelliteorbit.space/"><i class="fa-fw fas fa-images"></i><span> 摄影集</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener" href="https://note.satelliteorbit.space/%E7%AC%94%E8%AE%B0/"><i class="fa-fw fas fa-book"></i><span> 学习笔记</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">六轴陀螺仪算法驱动飞鼠</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-26T16:00:00.000Z" title="发表于 2025-11-27 00:00:00">2025-11-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-15T09:51:31.015Z" title="更新于 2025-12-15 17:51:31">2025-12-15</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">嵌入式开发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">8.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>31分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>​	简介：这个文档下包含了航博远达六轴陀螺仪项目和安卓TV鼠标项目的相关算法和问题</p>
<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><h2 id="寄存器是什么-？"><a href="#寄存器是什么-？" class="headerlink" title="寄存器是什么 ？"></a>寄存器是什么 ？</h2><p>​	<strong>寄存器是CPU用来暂存指令、数据和地址的电脑存储器。</strong>它位于CPU内部，存储速度想对硬盘、内存和缓存来说几乎是最快的。<br><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412182.webp"></p>
<p>​	其速度快的原因有三：1.由CPU中的逻辑单元直接存取。2.位于CPU中，与逻辑单元的走线短。3.寄存器自身的结构优势<br><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412183.webp"></p>
<h2 id="屏幕坐标系"><a href="#屏幕坐标系" class="headerlink" title="屏幕坐标系"></a>屏幕坐标系</h2><p>​	屏幕坐标系是用于描述屏幕上像素位置的二维坐标系统，是计算机图形学、用户界面设计（GUI）和交互式系统中的基础概念。以下是其核心定义、特点及应用的详细介绍：</p>
<h3 id="一、基本定义与核心要素"><a href="#一、基本定义与核心要素" class="headerlink" title="一、基本定义与核心要素"></a><strong>一、基本定义与核心要素</strong></h3><ol>
<li><strong>原点（Origin）</strong><ul>
<li><strong>默认位置</strong>：绝大多数屏幕坐标系的原点位于屏幕的 <strong>左上角</strong>（即屏幕的最左上方顶点）。</li>
<li><strong>数学表示</strong>：原点坐标为 <code>(0, 0)</code>，表示屏幕的起始位置。</li>
</ul>
</li>
<li><strong>坐标轴方向</strong><ul>
<li><strong>X 轴</strong>：水平方向，从原点向右延伸，数值随水平位置增加而增大。</li>
<li><strong>Y 轴</strong>：垂直方向，从原点向下延伸，数值随垂直位置增加而增大（<strong>与数学笛卡尔坐标系的 Y 轴方向相反</strong>，后者 Y 轴向上）。</li>
</ul>
</li>
<li><strong>单位</strong><ul>
<li>以 <strong>像素（Pixel）</strong> 为基本单位，坐标值为非负整数（如 <code>(100, 50)</code> 表示水平方向第 100 像素、垂直方向第 50 像素的位置）。</li>
</ul>
</li>
</ol>
<h3 id="二、坐标范围与分辨率"><a href="#二、坐标范围与分辨率" class="headerlink" title="二、坐标范围与分辨率"></a><strong>二、坐标范围与分辨率</strong></h3><ul>
<li><p><strong>范围</strong>：若屏幕分辨率为宽度×高度（如1920×1080），则：</p>
<ul>
<li>X 轴范围：<code>0 ≤ X &lt; 宽度</code>（如 0~1919）</li>
<li>Y 轴范围：<code>0 ≤ Y &lt; 高度</code>（如 0~1079）</li>
</ul>
</li>
<li><p><strong>坐标表示</strong>：屏幕上任意一点的位置由 <code>(X, Y)</code> 唯一确定，例如屏幕中心坐标为 <code>(宽度/2, 高度/2)</code>。</p>
</li>
</ul>
<h1 id="六轴陀螺仪算法"><a href="#六轴陀螺仪算法" class="headerlink" title="六轴陀螺仪算法"></a>六轴陀螺仪算法</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DT 0.01f        <span class="comment">// 采样时间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14f    <span class="comment">//Π</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">					低通滤波器</span></span><br><span class="line"><span class="comment">                    作用：减少高频噪声的影响，使数据更平滑。</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"><span class="comment">// 添加低通滤波结构体</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> alpha;    <span class="comment">// 滤波系数 (0.1-0.3)</span></span><br><span class="line">    <span class="type">int16_t</span> last_x;</span><br><span class="line">    <span class="type">int16_t</span> last_y;</span><br><span class="line">&#125; LowPassFilter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化滤波器</span></span><br><span class="line">LowPassFilter gyro_filter = &#123;.alpha = <span class="number">0.1</span>, .last_x = <span class="number">0</span>, .last_y = <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 低通滤波函数</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">apply_lowpass</span><span class="params">(LowPassFilter* filter, <span class="type">int</span>* x, <span class="type">int</span>* y)</span> &#123;</span><br><span class="line">    filter-&gt;last_x = filter-&gt;alpha * (*x) + (<span class="number">1</span> - filter-&gt;alpha) * filter-&gt;last_x;</span><br><span class="line">    filter-&gt;last_y = filter-&gt;alpha * (*y) + (<span class="number">1</span> - filter-&gt;alpha) * filter-&gt;last_y;</span><br><span class="line">    *x = filter-&gt;last_x; <span class="comment">// 注意这里需要类型转换</span></span><br><span class="line">    *y = filter-&gt;last_y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE_SENSITIVITY   0.0215f<span class="comment">// 0.0215f</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SENSITIVITY_CHANGE_THRESHOLD 55 <span class="comment">// 灵敏度切换阈值</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 动态灵敏度计算</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> <span class="title function_">dynamic_sensitivity</span><span class="params">(<span class="type">int16_t</span> delta)</span> &#123;</span><br><span class="line">    <span class="type">float</span> abs_delta = <span class="built_in">fabs</span>(delta);</span><br><span class="line">    <span class="keyword">if</span> (abs_delta &gt; SENSITIVITY_CHANGE_THRESHOLD) &#123;</span><br><span class="line">        <span class="keyword">return</span> BASE_SENSITIVITY * <span class="number">0.4f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BASE_SENSITIVITY * (<span class="number">1.0f</span> - <span class="number">0.6f</span> * (abs_delta / SENSITIVITY_CHANGE_THRESHOLD));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**********************************************************</span></span><br><span class="line"><span class="comment">		                辅助函数</span></span><br><span class="line"><span class="comment">**********************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：限制值范围</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int32_t</span> <span class="title function_">constrain</span><span class="params">(<span class="type">int32_t</span> value, <span class="type">int32_t</span> min_val, <span class="type">int32_t</span> max_val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; min_val) <span class="keyword">return</span> min_val;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; max_val) <span class="keyword">return</span> max_val;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 静态全局状态</span></span><br><span class="line"><span class="type">static</span> <span class="type">float</span> residual_x = <span class="number">0</span>, residual_y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RIGHT_COMPENSATION 1.018f  <span class="comment">// 根据实测调整此值</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在文件头部添加时间相关宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_BASE               (0x003fffff) <span class="comment">// 24bit count shift 2 bit as 1us/bit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_DELTA(x,y)         ((x) &gt;= (y) ? (x) - (y) : (TIME_BASE - (y) + (x)))</span></span><br><span class="line"><span class="type">uint32_t</span> CURRENT_TIME;  <span class="comment">// 假设存在外部时间计数器</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_gyro_mouse_report</span><span class="params">(<span class="type">uint8_t</span> is_ok_press)</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 1</span></span><br><span class="line">    <span class="comment">// 时间处理部分</span></span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> last_time = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> now = CURRENT_TIME;</span><br><span class="line">    <span class="type">uint32_t</span> delta_time = TIME_DELTA(now, last_time);</span><br><span class="line">    <span class="type">float</span> dt = delta_time * <span class="number">1e-6</span>f;  <span class="comment">// 转换为秒（假设每个计数=1us）</span></span><br><span class="line">    last_time = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时跳过无效时间差</span></span><br><span class="line">    <span class="keyword">if</span>(dt &lt;= <span class="number">0</span> || dt &gt; <span class="number">0.1f</span>) &#123;  <span class="comment">// 有效时间差范围1us~100ms</span></span><br><span class="line">        dt = <span class="number">0.01f</span>;  <span class="comment">// 默认10ms</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取原始陀螺仪数据（交换X/Y轴字段）</span></span><br><span class="line">    <span class="comment">// 注意：根据您的结构体定义，物理X轴对应 gyro_y，物理Y轴对应 gyro_x</span></span><br><span class="line">    <span class="type">int16_t</span> raw_gyro_x = (<span class="type">int16_t</span>)motion_packet.gyro_z; <span class="comment">// 物理X轴</span></span><br><span class="line">    <span class="type">int16_t</span> raw_gyro_y = (<span class="type">int16_t</span>)motion_packet.gyro_x; <span class="comment">// 物理Y轴</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int16_t</span> raw_gyro_roll = (<span class="type">int16_t</span>)motion_packet.gyro_y / <span class="number">10</span>; <span class="comment">// 获取横滚角的角速度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算横滚角和获取角度</span></span><br><span class="line">    <span class="type">float</span> acc_roll = -atan2f((<span class="type">int16_t</span>)motion_packet.acc_x, (<span class="type">int16_t</span>)motion_packet.acc_z) * (<span class="number">180.0f</span> / PI);</span><br><span class="line">    motion_packet.theta_y = acc_roll; <span class="comment">// 移除多余的*100</span></span><br><span class="line">    <span class="type">float</span> theta = -(motion_packet.theta_y * PI / <span class="number">180.0f</span>); <span class="comment">// 正确转换为弧度</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 坐标系转换，乘上Y轴的旋转矩阵</span></span><br><span class="line">    <span class="type">float</span> gx_ground = cosf(theta) * raw_gyro_y - sinf(theta) * raw_gyro_x;</span><br><span class="line">    <span class="type">float</span> gz_ground = sinf(theta) * raw_gyro_y + cosf(theta) * raw_gyro_x;</span><br><span class="line">    raw_gyro_x = -(<span class="type">int16_t</span>)gz_ground;</span><br><span class="line">    raw_gyro_y = -(<span class="type">int16_t</span>)gx_ground;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 零点校准（需根据静止状态校准 zero_x/zero_y）</span></span><br><span class="line">    <span class="type">static</span> <span class="type">int16_t</span> zero_x = <span class="number">0</span>, zero_y = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> delta_x = raw_gyro_x - zero_x;</span><br><span class="line">    <span class="type">int</span> delta_y = raw_gyro_y - zero_y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 应用低通滤波</span></span><br><span class="line">        apply_lowpass(&amp;gyro_filter, &amp;delta_x, &amp;delta_y);</span><br><span class="line"></span><br><span class="line">                       <span class="comment">// +++ 新增动态死区控制 +++</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义死区参数</span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> BASE_DEADZONE  16<span class="comment">//15// 27//25// 35//45//50//40    // 基础死区阈值</span></span></span><br><span class="line">    <span class="meta">#<span class="keyword">define</span> DYNAMIC_FACTOR  0.4f<span class="comment">//0.5f// 0.5f // 动态调整系数</span></span></span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> avg_delta_x = <span class="number">0</span>, avg_delta_y = <span class="number">0</span>;</span><br><span class="line">    <span class="type">const</span> <span class="type">float</span> alpha = <span class="number">0.035f</span>;<span class="comment">//0.03f;//0.04f;//0.1f;// 0.1f;     // 平滑系数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算动态平均（指数移动平均）</span></span><br><span class="line">    avg_delta_x = alpha * fabsf(delta_x) + (<span class="number">1</span> - alpha) * avg_delta_x;</span><br><span class="line">    avg_delta_y = alpha * fabsf(delta_y) + (<span class="number">1</span> - alpha) * avg_delta_y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算动态死区阈值（基础值 + 动态分量）</span></span><br><span class="line">    <span class="type">int</span> deadzone_x = BASE_DEADZONE + (<span class="type">int</span>)(avg_delta_x * DYNAMIC_FACTOR);</span><br><span class="line">    <span class="type">int</span> deadzone_y = BASE_DEADZONE + (<span class="type">int</span>)(avg_delta_y * DYNAMIC_FACTOR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 应用死区处理</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(delta_x) &lt; deadzone_x) delta_x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">abs</span>(delta_y) &lt; deadzone_y) delta_y = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对角速度积分，以移动的角度控制鼠标</span></span><br><span class="line">    <span class="type">float</span> angle_delta_x = delta_x * dt;  <span class="comment">// 度/秒 × 秒 = 度</span></span><br><span class="line">    <span class="type">float</span> angle_delta_y = delta_y * dt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态灵敏度（示例参数，需实际调试）</span></span><br><span class="line">    <span class="type">float</span> sensitivity = BASE_SENSITIVITY;</span><br><span class="line">    <span class="type">float</span> angle_speed = sqrtf(angle_delta_x*angle_delta_x + angle_delta_y*angle_delta_y)/dt;</span><br><span class="line">    <span class="comment">// if(angle_speed &lt; 5.0f) &#123;  // 慢速移动减低灵敏度，保持定位准确性</span></span><br><span class="line">    <span class="comment">//     sensitivity *= 0.013f;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算像素移动量（角度变化 × 灵敏度系数）</span></span><br><span class="line">    <span class="type">float</span> pixel_move_x = angle_delta_x * sensitivity * <span class="number">100.0f</span>; </span><br><span class="line">    <span class="type">float</span> pixel_move_y = angle_delta_y * sensitivity * <span class="number">100.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 运动累积和余数处理</span></span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> residual_x = <span class="number">0</span>, residual_y = <span class="number">0</span>;</span><br><span class="line">    pixel_move_x += residual_x;</span><br><span class="line">    pixel_move_y += residual_y;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> speed_x = (<span class="type">int32_t</span>)pixel_move_x;</span><br><span class="line">    <span class="type">int32_t</span> speed_y = (<span class="type">int32_t</span>)pixel_move_y;</span><br><span class="line">    </span><br><span class="line">    residual_x = pixel_move_x - speed_x;</span><br><span class="line">    residual_y = pixel_move_y - speed_y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制输出范围</span></span><br><span class="line">    speed_x = constrain(speed_x, <span class="number">-127</span>, <span class="number">127</span>);</span><br><span class="line">    speed_y = constrain(speed_y, <span class="number">-127</span>, <span class="number">127</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送鼠标报告</span></span><br><span class="line">    hidKbdSendMouseReport((<span class="type">uint8_t</span>)(speed_x &amp; <span class="number">0xFF</span>), </span><br><span class="line">                        (<span class="type">uint8_t</span>)(speed_y &amp; <span class="number">0xFF</span>), </span><br><span class="line">                        is_ok_press);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="三轴加速计算法"><a href="#三轴加速计算法" class="headerlink" title="三轴加速计算法"></a>三轴加速计算法</h1><p>​	基于SC7122由加速度控制的鼠标控制算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> DT 0.01f        <span class="comment">// 采样时间</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PI 3.14f    <span class="comment">//Π</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BASE_SENSITIVITY 0.005f   <span class="comment">// 基础灵敏度系数(需实测调整)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACC_DEADZONE    60         <span class="comment">// 加速度死区阈值</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在文件头部添加时间相关宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_BASE               (0x003fffff) <span class="comment">// 24bit count shift 2 bit as 1us/bit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_DELTA(x,y)         ((x) &gt;= (y) ? (x) - (y) : (TIME_BASE - (y) + (x)))</span></span><br><span class="line"><span class="type">uint32_t</span> CURRENT_TIME;  <span class="comment">// 假设存在外部时间计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /***************************************加速度计控制鼠标模块**************************************/</span></span><br><span class="line"><span class="comment">// 高通滤波器结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> alpha;         <span class="comment">// 低通滤波系数(0.05-0.2)</span></span><br><span class="line">    <span class="type">float</span> low_x;         <span class="comment">// X轴低频分量</span></span><br><span class="line">    <span class="type">float</span> low_y;         <span class="comment">// Y轴低频分量</span></span><br><span class="line">&#125; HighPassFilter;</span><br><span class="line"></span><br><span class="line">HighPassFilter acc_filter = &#123;.alpha = <span class="number">0.1</span>, .low_x = <span class="number">0</span>, .low_y = <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：限制值范围</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int32_t</span> <span class="title function_">constrain</span><span class="params">(<span class="type">int32_t</span> value, <span class="type">int32_t</span> min_val, <span class="type">int32_t</span> max_val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; min_val) <span class="keyword">return</span> min_val;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; max_val) <span class="keyword">return</span> max_val;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高通滤波处理</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">apply_highpass</span><span class="params">(HighPassFilter* filter, <span class="type">int16_t</span> acc_x, <span class="type">int16_t</span> acc_y, <span class="type">int</span>* high_x, <span class="type">int</span>* high_y)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新低频分量</span></span><br><span class="line">    filter-&gt;low_x = filter-&gt;alpha * acc_x + (<span class="number">1</span> - filter-&gt;alpha) * filter-&gt;low_x;</span><br><span class="line">    filter-&gt;low_y = filter-&gt;alpha * acc_y + (<span class="number">1</span> - filter-&gt;alpha) * filter-&gt;low_y;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算高频分量</span></span><br><span class="line">    *high_x = acc_x - filter-&gt;low_x;</span><br><span class="line">    *high_y = acc_y - filter-&gt;low_y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_gyro_mouse_report</span><span class="params">(<span class="type">uint8_t</span> is_ok_press)</span> &#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> last_time = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> residual_x = <span class="number">0</span>, residual_y = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取时间差</span></span><br><span class="line">    <span class="type">uint32_t</span> now = CURRENT_TIME;</span><br><span class="line">    <span class="type">uint32_t</span> delta_time = TIME_DELTA(now, last_time);</span><br><span class="line">    <span class="type">float</span> dt = delta_time * <span class="number">1e-6</span>f;  <span class="comment">// 转换为秒</span></span><br><span class="line">    last_time = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无效时间处理</span></span><br><span class="line">    <span class="keyword">if</span>(dt &lt;= <span class="number">0</span> || dt &gt; <span class="number">0.1f</span>) dt = <span class="number">0.01f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取原始加速度数据</span></span><br><span class="line">    <span class="type">int16_t</span> raw_acc_x = (<span class="type">int16_t</span>)motion_packet.acc_x;</span><br><span class="line">    <span class="type">int16_t</span> raw_acc_y = (<span class="type">int16_t</span>)motion_packet.acc_y;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 高通滤波去除重力分量</span></span><br><span class="line">    <span class="type">int</span> high_x, high_y;</span><br><span class="line">    apply_highpass(&amp;acc_filter, raw_acc_x, raw_acc_y, &amp;high_x, &amp;high_y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死区处理</span></span><br><span class="line">    <span class="type">int</span> delta_x = <span class="built_in">abs</span>(high_x) &gt; ACC_DEADZONE ? high_x : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> delta_y = <span class="built_in">abs</span>(high_y) &gt; ACC_DEADZONE ? high_y : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态灵敏度调整(根据加速度幅度)</span></span><br><span class="line">    <span class="type">float</span> speed_scale = fminf(fmaxf(sqrtf(delta_x*delta_x + delta_y*delta_y)/<span class="number">500.0f</span>, <span class="number">0.5f</span>), <span class="number">2.0f</span>);</span><br><span class="line">    <span class="type">float</span> sensitivity = BASE_SENSITIVITY * speed_scale;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算像素位移量</span></span><br><span class="line">    <span class="type">float</span> pixel_move_x = delta_x * sensitivity * dt * <span class="number">1000</span>; <span class="comment">// 乘以1000增强响应</span></span><br><span class="line">    <span class="type">float</span> pixel_move_y = delta_y * sensitivity * dt * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累积余数处理</span></span><br><span class="line">    pixel_move_x += residual_x;</span><br><span class="line">    pixel_move_y += residual_y;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> speed_x = (<span class="type">int32_t</span>)pixel_move_x;</span><br><span class="line">    <span class="type">int32_t</span> speed_y = (<span class="type">int32_t</span>)pixel_move_y;</span><br><span class="line"></span><br><span class="line">    residual_x = pixel_move_x - speed_x;</span><br><span class="line">    residual_y = pixel_move_y - speed_y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制输出范围</span></span><br><span class="line">    speed_x = constrain(speed_x, <span class="number">-127</span>, <span class="number">127</span>);</span><br><span class="line">    speed_y = constrain(speed_y, <span class="number">-127</span>, <span class="number">127</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送鼠标报告(Y轴方向取反符合屏幕坐标系)</span></span><br><span class="line">    hidKbdSendMouseReport((<span class="type">uint8_t</span>)speed_x, (<span class="type">uint8_t</span>)(-speed_y), is_ok_press);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h1 id="三轴加速度计驱动移植"><a href="#三轴加速度计驱动移植" class="headerlink" title="三轴加速度计驱动移植"></a>三轴加速度计驱动移植</h1><h2 id="驱动移植与数据获取"><a href="#驱动移植与数据获取" class="headerlink" title="驱动移植与数据获取"></a>驱动移植与数据获取</h2><p>​	在之前的尝试中，驱动i2c失败，log信息如下：</p>
<p>​                                    		<img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412184.webp">  </p>
<p>​	查看原理图和芯片手册，得知：<strong>当SDO(Single Drive Option,单驱动器选项)接为高电平时，7位I2C从机地址时0x19</strong>。而在SC7122中SDO是接地，地址为0x18，所以要进行修改。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412185.webp"><br><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412186.webp"></p>
<p>​	另外，由于SC7A20T的驱动比较久远和简陋，没有7122中SL_SC7I22_RawData_Read（）这个直接能读取加速度计数据的函数，参考原来SC7122中的函数并查询芯片手册得知：<strong>读取三轴数据的寄存器地址为0x28~0x2D</strong>。</p>
<p>​	修改后的SL_SC7I22_RawData_Read（）函数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读取三轴加速度计原始数据（寄存器地址0x28~0x2D，逐字节读取）</span></span><br><span class="line"><span class="comment"> * @param acc_data_buf 存储加速度数据的缓冲区，格式：[X轴, Y轴, Z轴]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SL_Accelerometer_RawData_Read</span><span class="params">(<span class="type">signed</span> <span class="type">short</span> *acc_data_buf)</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> raw_data[<span class="number">6</span>];  <span class="comment">// 存储6字节原始数据（0x28~0x2D）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> drdy_status = <span class="number">0x00</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> drdy_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待数据就绪（假设状态寄存器地址为0x0B，标志位为0x01）</span></span><br><span class="line">    <span class="keyword">while</span> ((drdy_status &amp; <span class="number">0x01</span>) != <span class="number">0x01</span>) &#123;</span><br><span class="line">        drdy_status = <span class="number">0x00</span>;</span><br><span class="line">        sl_delay(<span class="number">1</span>);  <span class="comment">// 延时1ms（需根据实际平台调整）</span></span><br><span class="line">        SL_Accelerometer_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, <span class="number">0x0B</span>, <span class="number">1</span>, &amp;drdy_status);</span><br><span class="line">        drdy_cnt++;</span><br><span class="line">        <span class="keyword">if</span> (drdy_cnt &gt; <span class="number">30000</span>) <span class="keyword">break</span>;  <span class="comment">// 超时退出</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逐字节读取加速度计三轴数据（非连续读取）</span></span><br><span class="line">    SL_Accelerometer_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, <span class="number">0x28</span>, <span class="number">1</span>, &amp;raw_data[<span class="number">0</span>]); <span class="comment">// X高字节</span></span><br><span class="line">    SL_Accelerometer_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, <span class="number">0x29</span>, <span class="number">1</span>, &amp;raw_data[<span class="number">1</span>]); <span class="comment">// X低字节</span></span><br><span class="line">    SL_Accelerometer_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, <span class="number">0x2A</span>, <span class="number">1</span>, &amp;raw_data[<span class="number">2</span>]); <span class="comment">// Y高字节</span></span><br><span class="line">    SL_Accelerometer_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, <span class="number">0x2B</span>, <span class="number">1</span>, &amp;raw_data[<span class="number">3</span>]); <span class="comment">// Y低字节</span></span><br><span class="line">    SL_Accelerometer_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, <span class="number">0x2C</span>, <span class="number">1</span>, &amp;raw_data[<span class="number">4</span>]); <span class="comment">// Z高字节</span></span><br><span class="line">    SL_Accelerometer_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, <span class="number">0x2D</span>, <span class="number">1</span>, &amp;raw_data[<span class="number">5</span>]); <span class="comment">// Z低字节</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 组合为16位有符号数据（大端序：高字节在前）</span></span><br><span class="line">    acc_data_buf[<span class="number">0</span>] = (<span class="type">signed</span> <span class="type">short</span>)(((<span class="type">unsigned</span> <span class="type">char</span>)raw_data[<span class="number">0</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> <span class="type">char</span>)raw_data[<span class="number">1</span>]); <span class="comment">// X轴</span></span><br><span class="line">    acc_data_buf[<span class="number">1</span>] = (<span class="type">signed</span> <span class="type">short</span>)(((<span class="type">unsigned</span> <span class="type">char</span>)raw_data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> <span class="type">char</span>)raw_data[<span class="number">3</span>]); <span class="comment">// Y轴</span></span><br><span class="line">    acc_data_buf[<span class="number">2</span>] = (<span class="type">signed</span> <span class="type">short</span>)(((<span class="type">unsigned</span> <span class="type">char</span>)raw_data[<span class="number">4</span>] &lt;&lt; <span class="number">8</span>) | (<span class="type">unsigned</span> <span class="type">char</span>)raw_data[<span class="number">5</span>]); <span class="comment">// Z轴</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> SL_Sensor_Algo_Release_Enable == 0x00</span></span><br><span class="line">    <span class="comment">// 调试输出（需确保LOG函数已定义）</span></span><br><span class="line">    LOG(<span class="string">&quot;RawData: AX=%d, AY=%d, AZ=%d\n&quot;</span>, acc_data_buf[<span class="number">0</span>], acc_data_buf[<span class="number">1</span>], acc_data_buf[<span class="number">2</span>]);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	经过上述修改后，没有i2c err的错误信息，但初始化函数返回值依然是-2（IIC 通信问题）：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412187.webp"></p>
<p>​	接下来应该继续排查地址、时钟频率和寄存器以及加速度计芯片是否虚焊</p>
<p>​	查询芯片手册，尝试根据SC7A20T手册中的芯片id地址读取芯片id的值，（WHO_AM_I寄存器），可以正常读取出来：</p>
<p>​	<strong>说明0x19的从机地址配置正确，芯片地址和芯片地址的值正确</strong>。证明总线物理层没有问题。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412188.webp"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**********sc7a20**********/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SL_SC7A20_CHIP_ID_ADDR    (unsigned char)0X0F</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SL_SC7A20_CHIP_ID_VALUE   (unsigned char)0X11</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_reg_value</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ret = SL_SC7A20_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, SL_SC7A20_CHIP_ID_ADDR, <span class="number">1</span>, &amp;i);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123; <span class="comment">// 通信成功</span></span><br><span class="line">    LOG(<span class="string">&quot;chip id is 0x%02X\r\n&quot;</span>, i); <span class="comment">// 正确输出芯片ID（如0x11）</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// 通信失败</span></span><br><span class="line">    LOG(<span class="string">&quot;read error: %d\r\n&quot;</span>, ret);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412189.webp"></p>
<p>​	在尝试使用CTRL_REG1再次验证通信读取功能时，读出来的值是0x47，即0100 0111，不是默认的0000 0111</p>
<p>​	查询寄存器配置表：0100表示电源模式和低功耗模式（50HZ），0111表示使用正常模式，XYZ轴均使能；<br><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412190.webp"><br><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412191.webp"></p>
<p>​	问题是，为什么能通过IIC读取寄存器的值却初始化失败了，需要分析一下初始化函数返回-2的原因：</p>
<p>​	<code>SL_SC7A20_Driver_Init</code> 函数的主要作用是对 <code>SL_SC7A20</code> 设备进行初始化配置。它根据传入的参数选择使用 SPI 或 IIC 接口进行通信，向设备的寄存器写入初始化数据，然后读取这些寄存器以验证写入操作是否成功，最后读取设备的芯片 ID 并返回其值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find device and init </span></span><br><span class="line"><span class="type">signed</span> <span class="type">char</span> <span class="title function_">SL_SC7A20_Driver_Init</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> Sl_spi_iic_init,<span class="type">unsigned</span> <span class="type">char</span> Sl_pull_up_mode)</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> i=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(Sl_spi_iic_init==<span class="number">0</span>)</span><br><span class="line">		SL_SPI_IIC_INTERFACE  = <span class="number">0</span>;<span class="comment">//spi</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		SL_SPI_IIC_INTERFACE  = <span class="number">1</span>;<span class="comment">//iic</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(SL_SPI_IIC_INTERFACE==<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        SL_SC7A20_INIT_REG1[<span class="number">4</span>]=(SL_SC7A20_INIT_REG1[<span class="number">4</span>]&amp;<span class="number">0xF3</span>)|Sl_pull_up_mode;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SL_SC7A20_INIT_REG1_NUM;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            SL_SC7A20_I2c_Spi_Write(SL_SPI_IIC_INTERFACE, SL_SC7A20_INIT_REG1[<span class="number">3</span>*i], SL_SC7A20_INIT_REG1[<span class="number">3</span>*i+<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SL_SC7A20_INIT_REG2_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将SL_SC7A20_INIT_REG2寄存器数组中预定义的值写入寄存器中</span></span><br><span class="line">        SL_SC7A20_I2c_Spi_Write(SL_SPI_IIC_INTERFACE, SL_SC7A20_INIT_REG2[<span class="number">3</span>*i], SL_SC7A20_INIT_REG2[<span class="number">3</span>*i+<span class="number">1</span>]);</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SL_SC7A20_INIT_REG2_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//将寄存器中的值读取到SL_SC7A20_INIT_REG2寄存器数组中</span></span><br><span class="line">        SL_SC7A20_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, SL_SC7A20_INIT_REG2[<span class="number">3</span>*i],<span class="number">1</span>, &amp;SL_SC7A20_INIT_REG2[<span class="number">3</span>*i+<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;SL_SC7A20_INIT_REG2_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//循环从 i=1 开始，即跳过第一个寄存器（i=0），仅验证 i=1、2、3、4 的寄存器，即只验证0x20,0x23,0x24.0x2E这四个寄存器</span></span><br><span class="line">        <span class="keyword">if</span>(SL_SC7A20_INIT_REG2[<span class="number">3</span>*i+<span class="number">1</span>]!=SL_SC7A20_INIT_REG2[<span class="number">3</span>*i+<span class="number">2</span>]) <span class="keyword">break</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">if</span>(i != SL_SC7A20_INIT_REG2_NUM)</span><br><span class="line">    &#123;</span><br><span class="line">		<span class="keyword">if</span>(SL_SPI_IIC_INTERFACE==<span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//reg write and read error by SPI</span></span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">        LOG(<span class="string">&quot;init fail \r\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">return</span> <span class="number">-2</span>;<span class="comment">//reg write and read error by IIC</span></span><br><span class="line">    &#125;</span><br><span class="line">	SL_SC7A20_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, SL_SC7A20_CHIP_ID_ADDR,<span class="number">1</span>, &amp;i);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line"><span class="comment">//	if(i==SL_SC7A20_CHIP_ID_VALUE)    return 1;</span></span><br><span class="line"><span class="comment">//	else                              return 0;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	所以可能的原因是即使能正确的读出一些寄存器，但特定寄存器的写入值与回读值不一致，所以返回值是-2，根据前面由CTRL_REG1读出的配置信息，也可能是时钟频率配置不对导致时序不匹配。明天需要对这部分进行检查。</p>
<p>​	以下定义了两个初始化寄存器的数组，三个字节一组为一个寄存器，前两个值分别表示寄存器的地址和值，第三个字节都是0x00，根据SL_SC7A20_Driver_Init函数，这个是用来存放前面写入的值，用于之后进行比对验证读写是否正常作为初始化是否成功的标志。第一个初始化寄存器数组有3个寄存器，第二个数组有5个寄存器。查询SC7A20T手册中的共52个寄存器的表，定义的这8个寄存器地址均存在且可读可写。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SL_SC7A20_INIT_REG1_NUM 3</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> SL_SC7A20_INIT_REG1[<span class="number">9</span>]=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x1E</span>,<span class="number">0x05</span>,<span class="number">0x00</span>, <span class="comment">//NVM_WR寄存器，手册中没有配置信息，查询资料可能是对非易失性存储器的写入使能操作</span></span><br><span class="line">    <span class="number">0x57</span>,<span class="number">0x00</span>,<span class="number">0x00</span>, <span class="comment">//DIG_CTRL寄存器，仅通过I2C通讯方式对SDO和I2C内部上拉电阻的进行开启和关闭</span></span><br><span class="line">    <span class="number">0x1E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>, <span class="comment">//NVM_WR寄存器，可能是清除 WREN 防止意外写入</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SL_SC7A20_INIT_REG2_NUM 5</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> SL_SC7A20_INIT_REG2[<span class="number">15</span>]=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x2E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>, <span class="comment">//FIFO_CTRL_REG</span></span><br><span class="line">    <span class="number">0x20</span>,<span class="number">0x47</span>,<span class="number">0x00</span>, <span class="comment">//CTRL_REG1寄存器，写入0100 0111，表示使用正常模式50Hz，XYZ均使能，可能需要修改</span></span><br><span class="line">    <span class="number">0x23</span>,<span class="number">0x98</span>,<span class="number">0x00</span>, <span class="comment">//CTRL_REG4</span></span><br><span class="line">    <span class="number">0x24</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>, <span class="comment">//CTRL_REG5</span></span><br><span class="line">    <span class="number">0x2E</span>,<span class="number">0x4F</span>,<span class="number">0x00</span>, <span class="comment">//FIFO_CTRL_REG</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	结合SL_SC7A20_Driver_Init对其的使用进一步分析,并尝试打印寄存器的回读值。但是直接在SL_SC7A20_Driver_Init中打印却栈溢出了，所以沿用之前写的read_reg_value直接读取指定寄存器的值。在SL_SC7A20_Driver_Init中，返回-2的直接原因是i不等于第二个初始化寄存器数组中的寄存器数量。在上一个for循环中，当写入的值和读取出的值不一样时，就会break导致i的值不对。通过read_reg_value函数读出的寄存器的值如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> * <span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> SL_SC7A20_INIT_REG2[<span class="number">15</span>]=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x2E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>, <span class="comment">//skip</span></span><br><span class="line">    <span class="number">0x20</span>,<span class="number">0x47</span>,<span class="number">0x00</span>, <span class="comment">//right value: 0x47 Default:0x07 -&gt;write sucess</span></span><br><span class="line">    <span class="number">0x23</span>,<span class="number">0x98</span>,<span class="number">0x00</span>, <span class="comment">//right value: 0x98 Default:0x00 -&gt;write sucess</span></span><br><span class="line">    <span class="number">0x24</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>, <span class="comment">//error value: 0x40 Default:0x00 -&gt;write fail (1100 0000 -&gt; 0100 0000) break</span></span><br><span class="line">    <span class="number">0x2E</span>,<span class="number">0x4F</span>,<span class="number">0x00</span>, <span class="comment">//right value: 0x4F Default:0x00 -&gt;write sucess</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​	0x24这个寄存器（CTRL_REG5）的值（BOOT）写入错误：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412192.webp"></p>
<p>​	先不管这个问题，尝试直接对acc寄存器的值读取，成功，与加速度有关的值在不断变化：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412193.webp"></p>
<p>​	接下来直接验证前面写的SL_Accelerometer_RawData_Read是否有用，并没有读出数据，原因应该是在新数据的判断上，把这部份注释掉后，成功读取了数据：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412194.webp"></p>
<p>​	但数据是否合理及可用要进一步验证，以及新数据判断部分，要根据芯片手册中以下这一句描述重新编写：</p>
<p>​	<strong>备注：查询新数据是否就位可采用如下条件进行判断：If((Read(0x27)&amp;0x0F)&#x3D;&#x3D;0x0F){break;}</strong></p>
<p>​	理解以下这一句的意思，0x27应该指的是状态寄存器（STATUS_REG），按位与0x0F如果还是0x0F，意味着XYZ轴的数据全部转换完成，参考7122判断新数据部分，编写如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="type">unsigned</span> <span class="type">char</span>  raw_data[<span class="number">12</span>];</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span>  drdy_satus;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> drdy_cnt=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>((drdy_satus&amp;<span class="number">0x0F</span>)!=<span class="number">0x0F</span>)</span><br><span class="line">&#123;</span><br><span class="line">	drdy_satus=<span class="number">0x00</span>;</span><br><span class="line">	sl_delay(<span class="number">1</span>);</span><br><span class="line">	SL_SC7A20_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, <span class="number">0x27</span>, <span class="number">1</span>, &amp;drdy_satus);</span><br><span class="line">	drdy_cnt++;</span><br><span class="line">	<span class="keyword">if</span>(drdy_cnt&gt;<span class="number">30000</span>) <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412195.webp"><br><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412196.webp"></p>
<p>​	正常读出数据，数据可以使鼠标移动，但是呈现的是随机运动状态，此时的数据输出为（板子平放不移动）：<br><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412197.webp"></p>
<p>​	可能是SL_Accelerometer_RawData_Read部分的rawdata计算有问题，先看看之前正常使用的航博远达的加速度数据是怎样的：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412198.webp"></p>
<p>​	修改rawdata有效数据计算后：<br><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412199.webp"></p>
<p>​	再尝试修改频率：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412200.webp"></p>
<p>​	数据变小了，但是在移动板子时，数据没有明显变化</p>
<p>​	使用SL_SC7A20_Read_FIFO_Buf采集的数据，这些数据可以初步控制鼠标，需要优化：</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412201.webp"></p>
<h2 id="数据优化的方向"><a href="#数据优化的方向" class="headerlink" title="数据优化的方向"></a>数据优化的方向</h2><p>​	首先注意到<strong>CTRL_REG4</strong>这个寄存器，它配置了加速度计的量程，在鼠标控制方面应该会用到。另外，这个寄存器同时可以配置自测试模式，之后可能会和产测部分有关。	</p>
<p>​	<strong>目前的配置：0x98(1001 1000)，即量程为量程为+&#x2F;-4G</strong></p>
<p>​	<strong>修改后的配置：0x88（1000 1000）</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412202.webp"></p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412203.webp"><br><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412204.webp"></p>
<p>​	首先明确<strong>量程指的是该加速度计能够测量的加速度的范围，它对获取到的数据有多方面的影响。</strong></p>
<h3 id="量程及其含义"><a href="#量程及其含义" class="headerlink" title="量程及其含义"></a><strong>量程及其含义</strong></h3><p>​	加速度计是用于测量加速度的传感器，而 “G” 是加速度的单位，代表重力加速度，其近似值为 9.8m&#x2F;s²。量程表示加速度计所能测量的加速度的最大值和最小值。</p>
<ul>
<li><strong>±2G 量程</strong>：意味着该加速度计能够测量的加速度范围是从 -2G（约 -19.6m&#x2F;s²）到 +2G（约 +19.6m&#x2F;s²）。</li>
<li><strong>±4G 量程</strong>：可测量的加速度范围是 -4G（约 -39.2m&#x2F;s²）到 +4G（约 +39.2m&#x2F;s²）。</li>
<li><strong>±8G 量程</strong>：测量范围为 -8G（约 -78.4m&#x2F;s²）到 +8G（约 +78.4m&#x2F;s²）。</li>
<li><strong>±16G 量程</strong>：能够测量 -16G（约 -156.8m&#x2F;s²）到 +16G（约 +156.8m&#x2F;s²）的加速度。</li>
</ul>
<h3 id="量程对获取数据的影响"><a href="#量程对获取数据的影响" class="headerlink" title="量程对获取数据的影响"></a>量程对获取数据的影响</h3><h4 id="1-分辨率"><a href="#1-分辨率" class="headerlink" title="1. 分辨率"></a>1. 分辨率</h4><p>​	分辨率是指加速度计能够分辨的最小加速度变化。<strong>量程和分辨率之间存在反比例关系，即量程越小，分辨率越高；量程越大，分辨率越低。</strong></p>
<p>​	例如，一个 16 位的加速度计，在 ±2G 量程下：<br>其可表示的数值范围是 -32768 到 +32767，总共 65536 个数值。那么每个数值对应的加速度变化（分辨率）为：2<em>G</em>×2&#x2F;65536≈0.000061<em>G</em>。</p>
<p>​	而在±16G 量程下，同样是 16 位数据，每个数值对应的加速度变化为：16<em>G</em>×2&#x2F;65536≈0.000488<em>G</em>。</p>
<p>​	可以看出，±2G 量程下的分辨率明显高于 ±16G 量程。因此，当你需要测量微小的加速度变化时，选择较小的量程可以获得更精确的数据。</p>
<p>​	<strong>因此，在同样的加速度情况下，选择更小的量程能够获得更大的输出数据</strong></p>
<h4 id="2-数据饱和风险"><a href="#2-数据饱和风险" class="headerlink" title="2. 数据饱和风险"></a>2. 数据饱和风险</h4><p>如果实际的加速度超出了加速度计当前设置的量程，就会导致数据饱和。数据饱和意味着加速度计输出的数值达到了其所能表示的最大值或最小值，无法再准确反映实际的加速度大小。</p>
<p>例如，当加速度计设置为 ±2G 量程时，如果实际的加速度达到了 +3G，加速度计输出的数值将是其所能表示的最大值，而不是真实的 +3G。此时，获取到的数据是不准确的，可能会对后续的分析和应用产生严重影响。</p>
<p><strong>因此，当你预计测量的加速度可能会较大时，应该选择较大的量程，以避免数据饱和。</strong></p>
<h4 id="3-噪声影响"><a href="#3-噪声影响" class="headerlink" title="3. 噪声影响"></a>3. 噪声影响</h4><p>一般来说，较小的量程在测量时受到噪声的影响相对较小。因为在小量程下，加速度计对微小的加速度变化更敏感，而噪声通常是相对较小的干扰信号。在小量程下，噪声占测量值的比例相对较大量程会更小，从而使测量结果更加准确。</p>
<p>例如，假设存在一个固定大小的噪声信号，在 ±2G 量程下，这个噪声可能只占测量范围的很小一部分；而在 ±16G 量程下，相同的噪声可能会对测量结果产生更明显的影响。</p>
<p>实际应用中的选择</p>
<ul>
<li><strong>测量微小加速度变化</strong>：如人体运动监测、地震监测等应用，通常需要测量微小的加速度变化，此时应选择较小的量程（如 ±2G），以获得更高的分辨率。</li>
<li><strong>测量较大加速度变化</strong>：如汽车碰撞测试、工业设备振动监测等应用，可能会遇到较大的加速度变化，这时需要选择较大的量程（如 ±16G），以避免数据饱和。</li>
</ul>
<h3 id="输出数据率及其含义"><a href="#输出数据率及其含义" class="headerlink" title="输出数据率及其含义"></a>输出数据率及其含义</h3><p><strong>输出数据率</strong>（Output Data Rate, ODR）指的是加速度计传感器每秒输出数据的次数，单位为赫兹（Hz）。例如：</p>
<ul>
<li><strong>1Hz</strong>表示传感器每秒输出 1 次数据（即每 1 秒更新一次测量结果）。</li>
<li><strong>400Hz</strong>表示传感器每秒输出 400 次数据（即每 2.5 毫秒更新一次测量结果）。</li>
</ul>
<h3 id="输出数据率对获取数据的影响"><a href="#输出数据率对获取数据的影响" class="headerlink" title="输出数据率对获取数据的影响"></a>输出数据率对获取数据的影响</h3><h4 id="1-时间分辨率与运动捕捉能力"><a href="#1-时间分辨率与运动捕捉能力" class="headerlink" title="1. 时间分辨率与运动捕捉能力"></a>1. <strong>时间分辨率与运动捕捉能力</strong></h4><ul>
<li><strong>高数据率（如 400Hz）</strong>：<ul>
<li><strong>优势</strong>：能捕捉快速变化的运动（如振动、冲击、高频动作），数据点密集，时间分辨率高（相邻数据点间隔仅 2.5 毫秒）。</li>
<li><strong>适用场景</strong>：运动分析（如跑步步态检测）、振动监测、实时姿态跟踪等需要高频数据的场景。</li>
<li><strong>缺点</strong>：数据量大幅增加（每秒 400 组 X&#x2F;Y&#x2F;Z 数据），可能导致 MCU 处理压力增大、功耗上升（传感器高频工作更耗电），且需注意数据存储或传输的带宽限制。</li>
</ul>
</li>
<li><strong>低数据率（如 1Hz）</strong>：<ul>
<li><strong>优势</strong>：数据量极少（每秒 1 组数据），功耗极低（传感器大部分时间处于休眠状态），适合电池供电的低功耗设备（如穿戴设备的静止监测）。</li>
<li><strong>适用场景</strong>：监测缓慢变化的运动（如静止姿态、长期倾角监测）、节能模式下的周期性数据采集。</li>
<li><strong>缺点</strong>：无法捕捉快速运动（可能丢失关键瞬态数据），时间分辨率差（相邻数据点间隔 1 秒）。</li>
</ul>
</li>
</ul>
<h4 id="2-抗混叠滤波与信号完整性"><a href="#2-抗混叠滤波与信号完整性" class="headerlink" title="2. 抗混叠滤波与信号完整性"></a>2. <strong>抗混叠滤波与信号完整性</strong></h4><p>根据<strong>奈奎斯特采样定理</strong>，为了不失真地还原信号，数据率需至少为信号最高频率的 2 倍。例如：</p>
<ul>
<li>若要测量频率为 100Hz 的振动信号，数据率需≥200Hz（通常建议设置为 2.5~5 倍信号频率以留安全裕度）。</li>
<li>若数据率过低（如 1Hz），高频信号会被 “混叠” 成低频信号，导致测量失真（例如快速振动被误判为缓慢变化）。</li>
</ul>
<h4 id="3-功耗与系统资源"><a href="#3-功耗与系统资源" class="headerlink" title="3. 功耗与系统资源"></a>3. <strong>功耗与系统资源</strong></h4><ul>
<li><strong>高数据率</strong>：传感器内部电路（如 ADC、数字滤波器）需高频工作，功耗显著增加（可能是低数据率的数十倍）。</li>
<li><strong>低数据率</strong>：传感器可进入 “睡眠 - 唤醒” 模式，大幅降低功耗（适合物联网、可穿戴设备的长期续航）。</li>
</ul>
<h4 id="4-数据处理与算法适配"><a href="#4-数据处理与算法适配" class="headerlink" title="4. 数据处理与算法适配"></a>4. <strong>数据处理与算法适配</strong></h4><ul>
<li>高数据率下，需考虑实时处理算法的效率（如卡尔曼滤波、FFT 频谱分析），避免数据堆积或处理延迟。</li>
<li>低数据率下，数据点稀疏，可能需要通过插值或融合其他传感器数据（如陀螺仪）来提升信号连续性。</li>
</ul>
<h3 id="如何配置输出数据率？"><a href="#如何配置输出数据率？" class="headerlink" title="如何配置输出数据率？"></a>如何配置输出数据率？</h3><p>通常通过设置传感器的<strong>寄存器</strong>来调整数据率（以常见的加速度计如 SC7A20 为例）：</p>
<ol>
<li>找到控制数据率的寄存器（如<code>CTRL_REG1</code>或<code>ODR_CTRL</code>）。</li>
<li>写入对应的值选择数据率（例如，通过二进制位选择 1Hz、10Hz、100Hz、400Hz 等预设档位）。</li>
<li>部分传感器支持 “自由运行” 模式（固定数据率持续输出）或 “单次测量” 模式（按需唤醒采样）。</li>
</ol>
<h3 id="总结：如何选择数据率？"><a href="#总结：如何选择数据率？" class="headerlink" title="总结：如何选择数据率？"></a>总结：如何选择数据率？</h3><ul>
<li><strong>高频运动 &#x2F; 实时性要求高</strong>：选高数据率（如 200Hz~400Hz），牺牲功耗换取精度。</li>
<li><strong>低功耗 &#x2F; 缓慢变化场景</strong>：选低数据率（如 1Hz~10Hz），优先节能和减少数据量。</li>
<li><strong>通用场景</strong>：平衡功耗和性能（如 50Hz~100Hz），适配大多数运动检测（如计步、姿态识别）。</li>
</ul>
<p>根据应用需求（如是否需要捕捉快速动作、设备续航要求、MCU 处理能力），合理选择数据率可优化系统整体性能。</p>
<h2 id="数据更新慢的问题"><a href="#数据更新慢的问题" class="headerlink" title="数据更新慢的问题"></a>数据更新慢的问题</h2><p>​	已经尝试过更改输出数据率，但数据更新仍比较慢，所以可能的原因是在代码获取数据的处理上存在某种延迟。</p>
<p>​	修改FIFO中的计算方式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x_buf[i] =(signed short int)(((unsigned char)sc7a20_data[2] * 256 ) + (unsigned char)sc7a20_data[1]);</span></span><br><span class="line"><span class="comment">// y_buf[i] =(signed short int)(((unsigned char)sc7a20_data[4] * 256 ) + (unsigned char)sc7a20_data[3]);</span></span><br><span class="line"><span class="comment">// z_buf[i] =(signed short int)(((unsigned char)sc7a20_data[6] * 256 ) + (unsigned char)sc7a20_data[5]);</span></span><br><span class="line"></span><br><span class="line">        x_buf[i] =(<span class="type">signed</span> <span class="type">short</span> <span class="type">int</span>)(((<span class="type">unsigned</span> <span class="type">char</span>)sc7a20_data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span> ) + (<span class="type">unsigned</span> <span class="type">char</span>)sc7a20_data[<span class="number">1</span>]);</span><br><span class="line">y_buf[i] =(<span class="type">signed</span> <span class="type">short</span> <span class="type">int</span>)(((<span class="type">unsigned</span> <span class="type">char</span>)sc7a20_data[<span class="number">4</span>] &lt;&lt; <span class="number">8</span> ) + (<span class="type">unsigned</span> <span class="type">char</span>)sc7a20_data[<span class="number">3</span>]);</span><br><span class="line">z_buf[i] =(<span class="type">signed</span> <span class="type">short</span> <span class="type">int</span>)(((<span class="type">unsigned</span> <span class="type">char</span>)sc7a20_data[<span class="number">6</span>] &lt;&lt; <span class="number">8</span> ) + (<span class="type">unsigned</span> <span class="type">char</span>)sc7a20_data[<span class="number">5</span>]);</span><br></pre></td></tr></table></figure>

<p>​	其他优化的地方：频率设置为400HZ，量程设置为2G</p>
<p>​	将updata函数接入FIFO计算中</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">SL_SC7A20_Read_FIFO_Buf</span><span class="params">(<span class="type">signed</span> <span class="type">short</span> *x_buf,<span class="type">signed</span> <span class="type">short</span> *y_buf,<span class="type">signed</span> <span class="type">short</span> *z_buf)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  i=<span class="number">0</span>;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  sc7a20_data[<span class="number">7</span>];</span><br><span class="line">    <span class="type">signed</span> <span class="type">short</span>   sl_sc7a20_data[<span class="number">3</span>];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span>  SL_FIFO_ACCEL_NUM;</span><br><span class="line"></span><br><span class="line">    SL_SC7A20_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, SL_SC7A20_FIFO_SRC_REG,<span class="number">1</span>,&amp;SL_FIFO_ACCEL_NUM); </span><br><span class="line">    SL_FIFO_ACCEL_NUM = SL_FIFO_ACCEL_NUM&amp;<span class="number">0x1f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SL_FIFO_ACCEL_NUM;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SL_SPI_IIC_INTERFACE==<span class="number">0</span>)</span><br><span class="line">            SL_SC7A20_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, SL_SC7A20_SPI_OUT_X_L,<span class="number">7</span>, &amp;sc7a20_data[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            SL_SC7A20_I2c_Spi_Read(SL_SPI_IIC_INTERFACE, SL_SC7A20_IIC_OUT_X_L,<span class="number">6</span>, &amp;sc7a20_data[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">// x_buf[i] =(signed short int)(((unsigned char)sc7a20_data[2] * 256 ) + (unsigned char)sc7a20_data[1]);</span></span><br><span class="line">        <span class="comment">// y_buf[i] =(signed short int)(((unsigned char)sc7a20_data[4] * 256 ) + (unsigned char)sc7a20_data[3]);</span></span><br><span class="line">        <span class="comment">// z_buf[i] =(signed short int)(((unsigned char)sc7a20_data[6] * 256 ) + (unsigned char)sc7a20_data[5]);</span></span><br><span class="line"></span><br><span class="line">                x_buf[i] =(<span class="type">signed</span> <span class="type">short</span> <span class="type">int</span>)(((<span class="type">unsigned</span> <span class="type">char</span>)sc7a20_data[<span class="number">2</span>] &lt;&lt; <span class="number">8</span> ) + (<span class="type">unsigned</span> <span class="type">char</span>)sc7a20_data[<span class="number">1</span>]);</span><br><span class="line">        y_buf[i] =(<span class="type">signed</span> <span class="type">short</span> <span class="type">int</span>)(((<span class="type">unsigned</span> <span class="type">char</span>)sc7a20_data[<span class="number">4</span>] &lt;&lt; <span class="number">8</span> ) + (<span class="type">unsigned</span> <span class="type">char</span>)sc7a20_data[<span class="number">3</span>]);</span><br><span class="line">        z_buf[i] =(<span class="type">signed</span> <span class="type">short</span> <span class="type">int</span>)(((<span class="type">unsigned</span> <span class="type">char</span>)sc7a20_data[<span class="number">6</span>] &lt;&lt; <span class="number">8</span> ) + (<span class="type">unsigned</span> <span class="type">char</span>)sc7a20_data[<span class="number">5</span>]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(sc7a20_data_flag ==<span class="number">1</span>) z_buf[i]=z_buf[i]+sc7a20_data_off;</span><br><span class="line">        x_buf[i] =x_buf[i] &gt;&gt;<span class="number">6</span>;<span class="comment">//10bits</span></span><br><span class="line">        y_buf[i] =y_buf[i] &gt;&gt;<span class="number">6</span>;<span class="comment">//10bits</span></span><br><span class="line">        z_buf[i] =z_buf[i] &gt;&gt;<span class="number">6</span>;<span class="comment">//10bits</span></span><br><span class="line"></span><br><span class="line">        motion_update_acc(x_buf[i],y_buf[i],z_buf[i]);</span><br><span class="line"></span><br><span class="line">	&#125;	</span><br><span class="line">	SL_SC7A20_I2c_Spi_Write(SL_SPI_IIC_INTERFACE, SL_SC7A20_FIFO_CTRL_REG, <span class="number">0X00</span>);		</span><br><span class="line"></span><br><span class="line">    SL_SC7A20_I2c_Spi_Write(SL_SPI_IIC_INTERFACE, SL_SC7A20_FIFO_CTRL_REG, <span class="number">0X4F</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(sc7a20_data_flag ==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;SL_FIFO_ACCEL_NUM;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sl_sc7a20_data[<span class="number">0</span>]=x_buf[i];</span><br><span class="line">            sl_sc7a20_data[<span class="number">1</span>]=y_buf[i];</span><br><span class="line">            sl_sc7a20_data[<span class="number">2</span>]=z_buf[i];</span><br><span class="line">            SC7A20_DATA_EXE(&amp;sl_sc7a20_data[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">return</span> SL_FIFO_ACCEL_NUM;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="算法和时间的调整"><a href="#算法和时间的调整" class="headerlink" title="算法和时间的调整"></a>算法和时间的调整</h2><p>​	在开启FIFO数据LOG的时候，控制的感觉比较好，但在关闭LOG调整参数时鼠标飞速移动，可能的原因时LOG占用了一定的时间，所以首先要调整的时定时器的间隔</p>
<p>​	经过多种尝试后，得到初步可用版本，参数如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BASE_SENSITIVITY 0.7f   <span class="comment">// 基础灵敏度系数(需实测调整)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACC_DEADZONE    5	    <span class="comment">// 加速度死区阈值</span></span></span><br><span class="line">HighPassFilter acc_filter = &#123;.alpha = <span class="number">0.2</span>, .low_x = <span class="number">0</span>, .low_y = <span class="number">0</span>&#125;; <span class="comment">//0.3-&gt; 0.2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算像素位移量 响应值1000 -&gt; 500</span></span><br><span class="line"><span class="type">float</span> pixel_move_x = delta_x * sensitivity * dt * <span class="number">500</span>; <span class="comment">// 乘以1000增强响应</span></span><br><span class="line"><span class="type">float</span> pixel_move_y = delta_y * sensitivity * dt * <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//寄存器</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">char</span> SL_SC7A20_INIT_REG2[<span class="number">15</span>]=</span><br><span class="line">&#123;</span><br><span class="line">    <span class="number">0x2E</span>,<span class="number">0x00</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x20</span>,<span class="number">0x77</span>,<span class="number">0x00</span>,   <span class="comment">//CTRL_REG1寄存器：修改0x47 -&gt; 0x77 50Hz-&gt; 400Hz  </span></span><br><span class="line">    <span class="number">0x23</span>,<span class="number">0x88</span>,<span class="number">0x00</span>,   <span class="comment">//CTRL_REG4寄存器：修改0x98 -&gt; 0x88 量程4g -&gt; 2g      </span></span><br><span class="line">    <span class="number">0x24</span>,<span class="number">0xC0</span>,<span class="number">0x00</span>,</span><br><span class="line">    <span class="number">0x2E</span>,<span class="number">0x4F</span>,<span class="number">0x00</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="添加扩展按键问题"><a href="#添加扩展按键问题" class="headerlink" title="添加扩展按键问题"></a>添加扩展按键问题</h1><p>​	由于时间问题，先完善其它重要的功能，首先是扩展按键的添加</p>
<p>​	移植keyboard文件，测试产测，有四个按键按下不亮，在log中down键的键值发送成了mosue的键值，有的直接发送0x00 0x00</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412205.webp"></p>
<p>​	查看原理图和板子丝印，这四个按键就是扩展的一列按键，说明添加扩展按键失败</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412206.webp"></p>
<p>​	接下来要理解一下添加扩展按键的逻辑</p>
<p>​	扩展按键的添加主要在keyboard.c和keyboard.h中修改</p>
<p>​	最后经排查，是硬件元器件贴放导致，修好板子后代码正常可用，产测都能点亮</p>
<h1 id="产测问题"><a href="#产测问题" class="headerlink" title="产测问题"></a>产测问题</h1><p>​	由于原来的7122六轴驱动中有自己检测函数，检测结果会更新到motion_ACC_selftest_state和motion_ACC_selftest_state中，产根据这些值判断是否发送键值。</p>
<p>​	但7A20的驱动比较简陋，没有类似的自检测函数，所以需要重新编写了简易版本，根据能否正确读出加速度计中芯片地址的值进行判断。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改前的检测函数</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hal_motion_ACC_GYR_state</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(motion_ACC_selftest_state &amp;&amp; motion_ACC_selftest_state)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改后的检测函数</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">hal_motion_ACC_GYR_state</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> ret = SL_SC7A20_I2c_Spi_Read(<span class="number">1</span>, <span class="number">0x0F</span>, <span class="number">1</span>, &amp;i); <span class="comment">//通过iic读取芯片地址的值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123; <span class="comment">// 通信成功</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0x11</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            LOG(<span class="string">&quot;chip id is 0x%02X test sucess\r\n&quot;</span>, i); <span class="comment">// 正确输出芯片ID（0x11）</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            LOG(<span class="string">&quot;read error: %d\r\n&quot;</span>, ret);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 通信失败</span></span><br><span class="line">        LOG(<span class="string">&quot;read error: %d\r\n&quot;</span>, ret);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412207.webp"></p>
<h1 id="语音问题"><a href="#语音问题" class="headerlink" title="语音问题"></a>语音问题</h1><h2 id="语音逻辑问题"><a href="#语音逻辑问题" class="headerlink" title="语音逻辑问题"></a>语音逻辑问题</h2><p>​	由于此代码是在航博远达的兼容国内外主机的代码上改的，所以语音逻辑需要做出修改</p>
<p>​	先看一下原来航博远达语音逻辑部分的更改提交记录</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412208.webp"></p>
<p>​	但走的是HID通道，看起来应该不影响谷歌的语音逻辑，尽管如此还是将其改回来</p>
<h2 id="语音使用问题"><a href="#语音使用问题" class="headerlink" title="语音使用问题"></a>语音使用问题</h2><p>​	样机在对应盒子上无法使用语音，板子在样机上也无法使用语音</p>
<h1 id="三轴加速度算法的优化"><a href="#三轴加速度算法的优化" class="headerlink" title="三轴加速度算法的优化"></a>三轴加速度算法的优化</h1><h2 id="现有状况的分析"><a href="#现有状况的分析" class="headerlink" title="现有状况的分析"></a>现有状况的分析</h2><p>​	SC7A20T中手册中对三轴线性加速度方向的描述如下，结合加速度传感器芯片的焊接位置和方向来看，定位孔在板子反面朝上时是位于右上角的。当板子正面使用时，Z轴正方形朝下，X轴正方向朝前，Y轴正方向朝右。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412209.webp"><br><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412210.webp"></p>
<p>​	以下是基于SC7A20T做出参数调整的由加速度计算的鼠标控制算法</p>
<p>​	改算法的主要逻辑是使用acc_y和acc_x的数据对鼠标进行上下左右的控制，并且使用高通滤波去除重力分量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BASE_SENSITIVITY 0.7f   <span class="comment">// 基础灵敏度系数(需实测调整)</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ACC_DEADZONE    5<span class="comment">//5        // 加速度死区阈值</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在文件头部添加时间相关宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_BASE               (0x003fffff) <span class="comment">// 24bit count shift 2 bit as 1us/bit</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TIME_DELTA(x,y)         ((x) &gt;= (y) ? (x) - (y) : (TIME_BASE - (y) + (x)))</span></span><br><span class="line"><span class="type">uint32_t</span> CURRENT_TIME;  <span class="comment">// 假设存在外部时间计数器</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// /***************************************加速度计控制鼠标模块**************************************/</span></span><br><span class="line"><span class="comment">// 高通滤波器结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">float</span> alpha;         <span class="comment">// 低通滤波系数(0.05-0.2)</span></span><br><span class="line">    <span class="type">float</span> low_x;         <span class="comment">// X轴低频分量</span></span><br><span class="line">    <span class="type">float</span> low_y;         <span class="comment">// Y轴低频分量</span></span><br><span class="line">&#125; HighPassFilter;</span><br><span class="line"></span><br><span class="line">HighPassFilter acc_filter = &#123;.alpha = <span class="number">0.2</span>, .low_x = <span class="number">0</span>, .low_y = <span class="number">0</span>&#125;; <span class="comment">//0.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数：限制值范围</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int32_t</span> <span class="title function_">constrain</span><span class="params">(<span class="type">int32_t</span> value, <span class="type">int32_t</span> min_val, <span class="type">int32_t</span> max_val)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; min_val) <span class="keyword">return</span> min_val;</span><br><span class="line">    <span class="keyword">if</span> (value &gt; max_val) <span class="keyword">return</span> max_val;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 高通滤波处理</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">apply_highpass</span><span class="params">(HighPassFilter* filter, <span class="type">int16_t</span> acc_x, <span class="type">int16_t</span> acc_y, <span class="type">int</span>* high_x, <span class="type">int</span>* high_y)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新低频分量</span></span><br><span class="line">    filter-&gt;low_x = filter-&gt;alpha * acc_x + (<span class="number">1</span> - filter-&gt;alpha) * filter-&gt;low_x;</span><br><span class="line">    filter-&gt;low_y = filter-&gt;alpha * acc_y + (<span class="number">1</span> - filter-&gt;alpha) * filter-&gt;low_y;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 计算高频分量</span></span><br><span class="line">    *high_x = acc_x - filter-&gt;low_x;</span><br><span class="line">    *high_y = acc_y - filter-&gt;low_y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_gyro_mouse_report</span><span class="params">(<span class="type">uint8_t</span> is_ok_press)</span> &#123;</span><br><span class="line">    <span class="comment">// LOG(&quot;lanuch acc mouse_report\r\n&quot;);</span></span><br><span class="line">    <span class="type">static</span> <span class="type">uint32_t</span> last_time = <span class="number">0</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">float</span> residual_x = <span class="number">0</span>, residual_y = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 获取时间差</span></span><br><span class="line">    <span class="type">uint32_t</span> now = CURRENT_TIME;</span><br><span class="line">    <span class="type">uint32_t</span> delta_time = TIME_DELTA(now, last_time);</span><br><span class="line">    <span class="type">float</span> dt = delta_time * <span class="number">1e-6</span>f;  <span class="comment">// 转换为秒</span></span><br><span class="line">    last_time = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无效时间处理</span></span><br><span class="line">    <span class="keyword">if</span>(dt &lt;= <span class="number">0</span> || dt &gt; <span class="number">0.1f</span>) dt = <span class="number">0.01f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取原始加速度数据</span></span><br><span class="line">    <span class="type">int16_t</span> raw_acc_x = (<span class="type">int16_t</span>)motion_packet.acc_y ;</span><br><span class="line">    <span class="type">int16_t</span> raw_acc_y = (<span class="type">int16_t</span>)motion_packet.acc_x ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 高通滤波去除重力分量</span></span><br><span class="line">    <span class="type">int</span> high_x, high_y;</span><br><span class="line">    apply_highpass(&amp;acc_filter, raw_acc_x, raw_acc_y, &amp;high_x, &amp;high_y);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 死区处理</span></span><br><span class="line">    <span class="type">int</span> delta_x = <span class="built_in">abs</span>(high_x) &gt; ACC_DEADZONE ? high_x : <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> delta_y = <span class="built_in">abs</span>(high_y) &gt; ACC_DEADZONE ? high_y : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态灵敏度调整(根据加速度幅度)</span></span><br><span class="line">    <span class="comment">// float speed_scale = fminf(fmaxf(sqrtf(delta_x*delta_x + delta_y*delta_y)/10.0f, 0.5f), 2.0f);</span></span><br><span class="line">    <span class="type">float</span> sensitivity = BASE_SENSITIVITY * <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算像素位移量</span></span><br><span class="line">    <span class="type">float</span> pixel_move_x = delta_x * sensitivity * dt * <span class="number">500</span>; <span class="comment">// 乘以1000增强响应</span></span><br><span class="line">    <span class="type">float</span> pixel_move_y = delta_y * sensitivity * dt * <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 累积余数处理</span></span><br><span class="line">    pixel_move_x += residual_x;</span><br><span class="line">    pixel_move_y += residual_y;</span><br><span class="line"></span><br><span class="line">    <span class="type">int32_t</span> speed_x = (<span class="type">int32_t</span>)pixel_move_x;</span><br><span class="line">    <span class="type">int32_t</span> speed_y = (<span class="type">int32_t</span>)pixel_move_y;</span><br><span class="line"></span><br><span class="line">    residual_x = pixel_move_x - speed_x;</span><br><span class="line">    residual_y = pixel_move_y - speed_y;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 限制输出范围</span></span><br><span class="line">    speed_x = constrain(speed_x, <span class="number">-127</span>, <span class="number">127</span>);</span><br><span class="line">    speed_y = constrain(speed_y, <span class="number">-127</span>, <span class="number">127</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发送鼠标报告(Y轴方向取反符合屏幕坐标系)</span></span><br><span class="line">    hidKbdSendMouseReport((<span class="type">uint8_t</span>)-speed_x, (<span class="type">uint8_t</span>)(-speed_y), is_ok_press);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="重力补偿"><a href="#重力补偿" class="headerlink" title="重力补偿"></a>重力补偿</h2><p>​	传感器测量的重力加速度约为290</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412211.webp"></p>
<p>由于每个检测加速度的轴检测的加速度大小不一样，补偿重力十分困难，另外，即使只是用x和y轴进行控制，在水平甩动的时候在两个轴上都有分量，难以控制，故需要将加速度计传感器更换为角速度（陀螺仪）传感器，即L3G4200D。</p>
<h1 id="陀螺仪芯片L3G4200D"><a href="#陀螺仪芯片L3G4200D" class="headerlink" title="陀螺仪芯片L3G4200D"></a>陀螺仪芯片L3G4200D</h1><h2 id="规格书和驱动代码重点"><a href="#规格书和驱动代码重点" class="headerlink" title="规格书和驱动代码重点"></a>规格书和驱动代码重点</h2><p>芯片陀螺仪方向 </p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412212.webp"></p>
<h2 id="驱动移植和数据读取"><a href="#驱动移植和数据读取" class="headerlink" title="驱动移植和数据读取"></a>驱动移植和数据读取</h2><p>使能陀螺仪读取数据由寄存器1控制</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412213.webp"></p>
<h2 id="电流功耗问题"><a href="#电流功耗问题" class="headerlink" title="电流功耗问题"></a>电流功耗问题</h2><p>在规格书的电气特性说明中，以下几点与测试相符：</p>
<p>1.工作电流：6mA</p>
<p>2.睡眠电流：1.5mA</p>
<p>3.关机电流：5uA</p>
<p>需要注意的是，从睡眠模式到工作模式和从关机模式到工作模式所需要的时间是不一样的。</p>
<p>从睡眠模式启动到工作模式要比从关机模式到工作模式更快。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412214.webp"></p>
<h1 id="六轴陀螺仪功耗优化"><a href="#六轴陀螺仪功耗优化" class="headerlink" title="六轴陀螺仪功耗优化"></a>六轴陀螺仪功耗优化</h1><h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>​	在固件版本HBYD_HB_019B_A_Mouse_K19S-2025032602-Q32-release中，客户提出遥控器在一周内使用就会没电，表示功耗过高，需要进行优化。</p>
<p><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251203175412215.webp" alt="客诉遥控器及信息"></p>
<h2 id="功耗问题分析"><a href="#功耗问题分析" class="headerlink" title="功耗问题分析"></a>功耗问题分析</h2><p>​	功耗过高本质是使用陀螺仪后没有关闭导致的</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Shadow</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/11/27/%E5%85%AD%E8%BD%B4%E9%99%80%E8%9E%BA%E4%BB%AA%E7%AE%97%E6%B3%95/">http://example.com/2025/11/27/%E5%85%AD%E8%BD%B4%E9%99%80%E8%9E%BA%E4%BB%AA%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Shadow的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%BC%80%E5%8F%91/">嵌入式开发</a></div><div class="post-share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251215174735747.webp" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/15/PH-RCMM/" title="飞利浦RC-MM和RC-5协议"><img class="cover" src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251215170009730.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">飞利浦RC-MM和RC-5协议</div></div><div class="info-2"><div class="info-item-1">飞利浦 RC-MM 协议  123400 = 001 = 110 = 211 = 3    飞利浦RC-5协议3010红外格式说明   IRReader波形数据  从IRReader波形数据的波形可以看出，3010的相关定义 帧定义一帧有15位（ 2位起始位 + 1位控制位 + 5位地址码 + 6位命令码 + 1位停止位） 位定义   逻辑值 低电平时长 高电平时长 总周期 (上升沿到上升沿) 解码依据    0 880 µs 880 µs 1.76 ms 测量到脉冲间隔较短   1 1.8 ms 880 µs 2.68 ms 测量到脉冲间隔较长   数据规则1.起始位规则：一帧的开头两个位（起始位）是“11”还是“10”，由数据码（D5-D0）的值决定。这是一种将数据码高位信息“隐藏”在起始位中的巧妙设计。  规则A：如果数据码 ≤ 0x3F（即≤63），则起始位固定为 “11”。 规则B：如果数据码 &gt; 0x3F，则：在发送数据码部分时，只发送其低6位（舍弃最高位）。同时，将起始位设置为 “10”。 目的：此规则等效于将数据码的最高位“移动”到了起始位中发送，使得6位数...</div></div></div></a><a class="pagination-related" href="/2025/11/26/03_%E9%BC%A0%E6%A0%87%E9%A1%B9%E7%9B%AE/" title="鼠标项目"><img class="cover" src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251207222738943.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">鼠标项目</div></div><div class="info-2"><div class="info-item-1">鼠标项目介绍​	这是笔者在学习产品结构设计所作的完整项目，也是笔者转行之初写在简历上的项目 材料ABS牌号：PA757（生产厂商： 台湾奇美）  外壳材料：ABS或ABS+PC 为什么不直接用PC料 ？ 1.PC料想对贵一些 2.容易产生应力集中或应力开裂的情况，特别在卡扣根部产生应力集中可能使卡扣断裂 滚轮材料：软胶 脚垫材料：铁氟龙或pe 产品较为高端：选铁氟龙 产品较为低端：选pe 脚垫背面背胶。可以直接粘在鼠标底部  产品使用脚垫可以遮蔽螺丝柱和进胶点，使其不影响外观效果 螺丝使用2毫米自攻螺丝  设计参数产品壁厚上壳、中壳、下壳壁厚均为2mm  拔模斜度上下壳给的拔模斜度为2度   鼠标尾部特殊部分留有7度的拔模角  扣合量上壳与中壳部分卡扣后方为0.8mm 前面是1.4mm   中壳与下壳部分卡扣 为1.9mm，这个是斜着插入的  止口间隙止口间隙给到0.05mm，也就是5个丝（1丝&#x3D;0.01mm）  美工线间隙 BOSS柱ABS材料或ABS+PC材料选用0.8的内径系数 自攻螺丝选用PA 2mm自攻螺丝，2mm*0.8&#x3D;1.6mm  所以boss...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/11/26/01_%E5%B7%A5%E4%BD%9C%E6%97%A5%E6%8A%A5/" title="工作日报"><img class="cover" src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251215174725892.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-26</div><div class="info-item-2">工作日报</div></div><div class="info-2"><div class="info-item-1">2025(1)已掌握结构设计技术和知识： 1.CAD绘制二维图 2.creo实体建模：拉伸、旋转、扫描、阵列 3.creo曲面建模：边界混合及其约束、样式曲面、曲面拆分 4.creo钣金建模 5.creo运动仿真 6.模具知识 7.材料知识 (2)已完成项目： 1.遥控器项目 2.鼠标项目 (3)还需学习和拓展的： 1.加强曲面建模，完成作业 2.加强参数化建模，关系式的运用（关系式扫描、关系式阵列） 3.学习solidworks、UG的基本实体建模 4.学习犀牛软件基本曲面建模 5.学习keyshot进行产品渲染 6.学习Anasy进行产品仿真 7.系统复杂材料、模具、工艺 8.优化项目和简历 8.25-8.29周报本周工作安排1.遥控器建模结构设计及优化 2.模具及材料知识学习（一加一教育） 8.261.完成下壳电池槽部分建模   2.学习模具： 1）两板模与三板模 2）浇口 8.271.学习模具：1）热流道  2.P81遥控器项目建模： 1）建立PCB、硅胶按键、电池零件 2）解决之前在对电池槽抽壳时导致的下壳中间空缺问题 3）完善电池槽部分结构 8.281.学习模具:1 ...</div></div></div></a><a class="pagination-related" href="/2025/12/15/PH-RCMM/" title="飞利浦RC-MM和RC-5协议"><img class="cover" src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251215170009730.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-15</div><div class="info-item-2">飞利浦RC-MM和RC-5协议</div></div><div class="info-2"><div class="info-item-1">飞利浦 RC-MM 协议  123400 = 001 = 110 = 211 = 3    飞利浦RC-5协议3010红外格式说明   IRReader波形数据  从IRReader波形数据的波形可以看出，3010的相关定义 帧定义一帧有15位（ 2位起始位 + 1位控制位 + 5位地址码 + 6位命令码 + 1位停止位） 位定义   逻辑值 低电平时长 高电平时长 总周期 (上升沿到上升沿) 解码依据    0 880 µs 880 µs 1.76 ms 测量到脉冲间隔较短   1 1.8 ms 880 µs 2.68 ms 测量到脉冲间隔较长   数据规则1.起始位规则：一帧的开头两个位（起始位）是“11”还是“10”，由数据码（D5-D0）的值决定。这是一种将数据码高位信息“隐藏”在起始位中的巧妙设计。  规则A：如果数据码 ≤ 0x3F（即≤63），则起始位固定为 “11”。 规则B：如果数据码 &gt; 0x3F，则：在发送数据码部分时，只发送其低6位（舍弃最高位）。同时，将起始位设置为 “10”。 目的：此规则等效于将数据码的最高位“移动”到了起始位中发送，使得6位数...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/assets/head.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Shadow</div><div class="author-info-description">须知少日拏云志，曾许人间第一流。</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/AbyssTrace"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来到我的博客！  <br>自建图床： image.satelliteorbit.space <br>笔记本： note.satelliteorbit.space <br>摄影集： photography.satelliteorbit.space    </div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">相关知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88-%EF%BC%9F"><span class="toc-number">1.1.</span> <span class="toc-text">寄存器是什么 ？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%8F%E5%B9%95%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="toc-number">1.2.</span> <span class="toc-text">屏幕坐标系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%A0%B8%E5%BF%83%E8%A6%81%E7%B4%A0"><span class="toc-number">1.2.1.</span> <span class="toc-text">一、基本定义与核心要素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%9D%90%E6%A0%87%E8%8C%83%E5%9B%B4%E4%B8%8E%E5%88%86%E8%BE%A8%E7%8E%87"><span class="toc-number">1.2.2.</span> <span class="toc-text">二、坐标范围与分辨率</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E8%BD%B4%E9%99%80%E8%9E%BA%E4%BB%AA%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">六轴陀螺仪算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F%E8%AE%A1%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">三轴加速计算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F%E5%BA%A6%E8%AE%A1%E9%A9%B1%E5%8A%A8%E7%A7%BB%E6%A4%8D"><span class="toc-number">4.</span> <span class="toc-text">三轴加速度计驱动移植</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E7%A7%BB%E6%A4%8D%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96"><span class="toc-number">4.1.</span> <span class="toc-text">驱动移植与数据获取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BC%98%E5%8C%96%E7%9A%84%E6%96%B9%E5%90%91"><span class="toc-number">4.2.</span> <span class="toc-text">数据优化的方向</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8F%E7%A8%8B%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">量程及其含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8F%E7%A8%8B%E5%AF%B9%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">4.2.2.</span> <span class="toc-text">量程对获取数据的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%88%86%E8%BE%A8%E7%8E%87"><span class="toc-number">4.2.2.1.</span> <span class="toc-text">1. 分辨率</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%95%B0%E6%8D%AE%E9%A5%B1%E5%92%8C%E9%A3%8E%E9%99%A9"><span class="toc-number">4.2.2.2.</span> <span class="toc-text">2. 数据饱和风险</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%99%AA%E5%A3%B0%E5%BD%B1%E5%93%8D"><span class="toc-number">4.2.2.3.</span> <span class="toc-text">3. 噪声影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E7%8E%87%E5%8F%8A%E5%85%B6%E5%90%AB%E4%B9%89"><span class="toc-number">4.2.3.</span> <span class="toc-text">输出数据率及其含义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E7%8E%87%E5%AF%B9%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">4.2.4.</span> <span class="toc-text">输出数据率对获取数据的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%97%B6%E9%97%B4%E5%88%86%E8%BE%A8%E7%8E%87%E4%B8%8E%E8%BF%90%E5%8A%A8%E6%8D%95%E6%8D%89%E8%83%BD%E5%8A%9B"><span class="toc-number">4.2.4.1.</span> <span class="toc-text">1. 时间分辨率与运动捕捉能力</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8A%97%E6%B7%B7%E5%8F%A0%E6%BB%A4%E6%B3%A2%E4%B8%8E%E4%BF%A1%E5%8F%B7%E5%AE%8C%E6%95%B4%E6%80%A7"><span class="toc-number">4.2.4.2.</span> <span class="toc-text">2. 抗混叠滤波与信号完整性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8A%9F%E8%80%97%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90"><span class="toc-number">4.2.4.3.</span> <span class="toc-text">3. 功耗与系统资源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E4%B8%8E%E7%AE%97%E6%B3%95%E9%80%82%E9%85%8D"><span class="toc-number">4.2.4.4.</span> <span class="toc-text">4. 数据处理与算法适配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AE%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE%E7%8E%87%EF%BC%9F"><span class="toc-number">4.2.5.</span> <span class="toc-text">如何配置输出数据率？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E7%8E%87%EF%BC%9F"><span class="toc-number">4.2.6.</span> <span class="toc-text">总结：如何选择数据率？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.3.</span> <span class="toc-text">数据更新慢的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E6%97%B6%E9%97%B4%E7%9A%84%E8%B0%83%E6%95%B4"><span class="toc-number">4.4.</span> <span class="toc-text">算法和时间的调整</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E6%89%A9%E5%B1%95%E6%8C%89%E9%94%AE%E9%97%AE%E9%A2%98"><span class="toc-number">5.</span> <span class="toc-text">添加扩展按键问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%A7%E6%B5%8B%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">产测问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%AD%E9%9F%B3%E9%97%AE%E9%A2%98"><span class="toc-number">7.</span> <span class="toc-text">语音问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E9%9F%B3%E9%80%BB%E8%BE%91%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.</span> <span class="toc-text">语音逻辑问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%AD%E9%9F%B3%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.2.</span> <span class="toc-text">语音使用问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E8%BD%B4%E5%8A%A0%E9%80%9F%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">8.</span> <span class="toc-text">三轴加速度算法的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E6%9C%89%E7%8A%B6%E5%86%B5%E7%9A%84%E5%88%86%E6%9E%90"><span class="toc-number">8.1.</span> <span class="toc-text">现有状况的分析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%8A%9B%E8%A1%A5%E5%81%BF"><span class="toc-number">8.2.</span> <span class="toc-text">重力补偿</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%99%80%E8%9E%BA%E4%BB%AA%E8%8A%AF%E7%89%87L3G4200D"><span class="toc-number">9.</span> <span class="toc-text">陀螺仪芯片L3G4200D</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%84%E6%A0%BC%E4%B9%A6%E5%92%8C%E9%A9%B1%E5%8A%A8%E4%BB%A3%E7%A0%81%E9%87%8D%E7%82%B9"><span class="toc-number">9.1.</span> <span class="toc-text">规格书和驱动代码重点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E7%A7%BB%E6%A4%8D%E5%92%8C%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%8F%96"><span class="toc-number">9.2.</span> <span class="toc-text">驱动移植和数据读取</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E6%B5%81%E5%8A%9F%E8%80%97%E9%97%AE%E9%A2%98"><span class="toc-number">9.3.</span> <span class="toc-text">电流功耗问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E8%BD%B4%E9%99%80%E8%9E%BA%E4%BB%AA%E5%8A%9F%E8%80%97%E4%BC%98%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">六轴陀螺仪功耗优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%83%8C%E6%99%AF"><span class="toc-number">10.1.</span> <span class="toc-text">问题背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%9F%E8%80%97%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90"><span class="toc-number">10.2.</span> <span class="toc-text">功耗问题分析</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/12/15/PH-RCMM/" title="飞利浦RC-MM和RC-5协议"><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251215170009730.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="飞利浦RC-MM和RC-5协议"/></a><div class="content"><a class="title" href="/2025/12/15/PH-RCMM/" title="飞利浦RC-MM和RC-5协议">飞利浦RC-MM和RC-5协议</a><time datetime="2025-12-14T16:00:00.000Z" title="发表于 2025-12-15 00:00:00">2025-12-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/27/%E5%85%AD%E8%BD%B4%E9%99%80%E8%9E%BA%E4%BB%AA%E7%AE%97%E6%B3%95/" title="六轴陀螺仪算法驱动飞鼠"><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251215174735747.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="六轴陀螺仪算法驱动飞鼠"/></a><div class="content"><a class="title" href="/2025/11/27/%E5%85%AD%E8%BD%B4%E9%99%80%E8%9E%BA%E4%BB%AA%E7%AE%97%E6%B3%95/" title="六轴陀螺仪算法驱动飞鼠">六轴陀螺仪算法驱动飞鼠</a><time datetime="2025-11-26T16:00:00.000Z" title="发表于 2025-11-27 00:00:00">2025-11-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/26/01_%E5%B7%A5%E4%BD%9C%E6%97%A5%E6%8A%A5/" title="工作日报"><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251215174725892.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="工作日报"/></a><div class="content"><a class="title" href="/2025/11/26/01_%E5%B7%A5%E4%BD%9C%E6%97%A5%E6%8A%A5/" title="工作日报">工作日报</a><time datetime="2025-11-25T16:00:00.000Z" title="发表于 2025-11-26 00:00:00">2025-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/26/02_%E9%81%A5%E6%8E%A7%E5%99%A8%E9%A1%B9%E7%9B%AE/" title="遥控器项目"><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251207222326402.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="遥控器项目"/></a><div class="content"><a class="title" href="/2025/11/26/02_%E9%81%A5%E6%8E%A7%E5%99%A8%E9%A1%B9%E7%9B%AE/" title="遥控器项目">遥控器项目</a><time datetime="2025-11-25T16:00:00.000Z" title="发表于 2025-11-26 00:00:00">2025-11-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/11/26/03_%E9%BC%A0%E6%A0%87%E9%A1%B9%E7%9B%AE/" title="鼠标项目"><img src="https://cdn.jsdelivr.net/gh/AbyssTrace/picgo_img_src@main/img/20251207222738943.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="鼠标项目"/></a><div class="content"><a class="title" href="/2025/11/26/03_%E9%BC%A0%E6%A0%87%E9%A1%B9%E7%9B%AE/" title="鼠标项目">鼠标项目</a><time datetime="2025-11-25T16:00:00.000Z" title="发表于 2025-11-26 00:00:00">2025-11-26</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://free.picui.cn/free/2025/12/01/692d4c54014d4.png);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2025 By Shadow</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><div class="js-pjax"><script>(() => {
  let initFn = window.walineFn || null
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const destroyWaline = ele => ele.destroy()

  const initWaline = (Fn, el = document, path = window.location.pathname) => {
    const waline = Fn({
      el: el.querySelector('#waline-wrap'),
      serverURL: 'https://comment.satelliteorbit.space/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      comment: false,
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    if (isShuoshuo) {
      window.shuoshuoComment.destroyWaline = () => {
        destroyWaline(waline)
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const loadWaline = (el, path) => {
    if (initFn) initWaline(initFn, el, path)
    else {
      btf.getCSS('https://cdn.jsdelivr.net/npm/@waline/client@3.7.1/dist/waline.min.css')
        .then(() => import('https://cdn.jsdelivr.net/npm/@waline/client@3.7.1/dist/waline.min.js'))
        .then(({ init }) => {
          initFn = init || Waline.init
          initWaline(initFn, el, path)
          window.walineFn = initFn
        })
    }
  }

  if (isShuoshuo) {
    'Waline' === 'Waline'
      ? window.shuoshuoComment = { loadComment: loadWaline } 
      : window.loadOtherComment = loadWaline
    return
  }

  if ('Waline' === 'Waline' || !false) {
    if (false) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
    else setTimeout(loadWaline, 0)
  } else {
    window.loadOtherComment = loadWaline
  }
})()</script></div><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script async data-pjax src="/"></script></div></body></html>